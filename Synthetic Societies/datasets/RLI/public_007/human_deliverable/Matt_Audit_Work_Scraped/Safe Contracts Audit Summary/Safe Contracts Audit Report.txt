Repository URL: https://github.com/safe-global/safe-contracts
Full commit hash: eb93dbb
========================================================================
Findings Summary:
==================
M1: Broken guard can cause DoS
Medium severity issue
Impact: High Likelihood: Low
Target: Safe.sol Type: Denial of service
Description
Safe can set up a guard contract that executes functions before
address guard = getGuard();
{
  if (guard != address(0)) {
  Guard(guard).checkTransaction(
  // Transaction info
  ...
  );
  }
}
and after transactions.
{
  if (guard != address(0)) {
  Guard(guard).checkAfterExecution(txHash, success);
  }
}
If one of these two functions is broken or just reverts, it can cause DoS for
the whole Safe.
Vulnerability scenario
The guard setup function is protected by authorized modifier, thus can be
called by Safe transaction only. However, if the guard function reverts for
any reason, there is no way to execute a Safe transaction and change the
guard address.
Recommendation
Guard can work as an additional layer of security for the Safe. Nevertheless, if
the guard functions contain an issue that causes reverting transactions, Safe
should be able to execute transactions without it or have the ability to
change the guard address.
Fix 1.1
Client’s response:
• "Modules can be used for recovery"
• Add documentation for guards and warn about usage
Pull request #535 with added documentation.
===========================================================================
M2: Lack of contract check
Medium severity issue
Impact: Medium Likelihood: Low
Target: SecuredTokenTransfer.sol,
Execute.sol
Type: Data validation
Description
For transferring tokens from the Safe contract to the payment token receiver
following function used:
function transferToken(address token, address receiver, uint256 amount)
internal returns (bool transferred) {
  // 0xa9059cbb - keccack("transfer(address,uint256)")
  bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver,
amount);
  // solhint-disable-next-line no-inline-assembly
  assembly {
  // We write the return value to scratch space.
  // See
https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#lay
out-in-memory
  let success := call(sub(gas(), 10000), token, 0, add(data, 0x20),
mload(data), 0, 0x20)
  switch returndatasize()
  case 0 {
  transferred := success
  }
  case 0x20 {
  transferred := iszero(or(iszero(success), iszero(mload(0))))
  }
  default {
  transferred := 0
  }
  }
}
It uses a low-level call to a predefined function selector
"transfer(address,uint256)" on the token’s address. However, if the address
is not a contract, a low-level call returns 1, because no revert happens inside
the call.
The second place where contract check is suitable but not performed is the
execute function in the Executor contract.
if (operation == Enum.Operation.DelegateCall) {
  // solhint-disable-next-line no-inline-assembly
  assembly {
  success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0,
0)
  }
} else {
  // solhint-disable-next-line no-inline-assembly
  assembly {
  success := call(txGas, to, value, add(data, 0x20), mload(data), 0,
0)
  }
}
The function is called from the Safe execution function, where the check of
whether the address to is a contract is not performed either. Especially for a
delegate call, it is important to check whether the address is a contract.
Vulnerability scenario
Suppose the wrong address is provided as a token or destination address. In
that case, the Safe contract will assume that the token transfer or call was
successful because the variable success is equal to 1.
Recommendation
Perform the check whether the address is a contract before calling the low level call.
Additionally, differ the logic for EOA and contract calls.
Fix 1.1
Client’s response:
• "Checks for the execution should be done on interface
level. Contracts should provide full flexibility. No user
funds at risk"
• Add documentation that outlines that it is the responsibility of the
interface/relayer to check this.
Pull request #536 with added in-code documentation.
===========================================================================
L1: Error-prone proxy constructor
Low severity issue
Impact: Low Likelihood: Low
Target: SafeProxy.sol Type: Data validation
Description
The constructor of the SafeProxy contract does not use robust verification
for singleton address. Only the check for zero address is performed.
Vulnerability scenario
Passing the wrong singleton address to the constructor of the SafeProxy
contract will lead to the unintended behavior of the contract.
Recommendation
More robust verification can be performed by checking the singletons’s
identifier against the constant. For example:
contract SafeProxy{
  constructor(address _singleton) {
  require(Safe(payable(_singleton)).identifier() == keccak256("safe-
1.4.0"), "Invalid singleton address provided");
  singleton = _singleton;
  }
  ...
}
contract Safe{
  function identifier() public pure returns (bytes32) {
  return keccak256("safe-1.4.0");
  ...
}
Fix 1.1
Client’s response:
• "This is intended behavior"
• "Proposed solution is not stable enough as it is easily
possible to “fake” the check. Alternatively we could fix it
to a specific address, but this would defeat the purpose of
a generalized proxy."
===========================================================================
W1: Usage of delegatecalls
Impact: Warning Likelihood: N/A
Target: Safe.sol Type: Data validation
Description
Delegatecall in setup
The Safe contract uses the setup function to initialize its state. The setup
function can be viewed as a point of centralization as it is called before the
owners are set. What is more, the setup function can also result in a
delegatecall. That increases the possibility for the deployer to set up the
contract dishonestly.
To trust the setup, the owners must verify the code and the inputs to the
setup function.
The setup process should be as transparent as possible to allow all the
parties to verify its output. If a delegate call is used, the probability that
everyone will verify the setup is lower.
Delegatecall in execute
The delegatecall can also be triggered from executeTransaction or
executeTransactionFromModule. Such calls are inherently dangerous as they
can transform the contract’s storage into an inconsistent state. The target
contract might not be audited and might break some important invariants
(like the owner list validity, nonce linearly decreases, the threshold is at most
len(owners) etc.)). If the nonce decreases, transactions might be replayed. If
the threshold exceeds the number of owners, the contract might be locked
forever, etc.
Recommendation
Include the bare minimum of logic in the setup function. If a more delicate
setup is needed, consider moving it to the execute portion of the contract.
The delegatecall may be eventually needed, but splitting the setup into two
parts makes the verification process more transparent.
More generally, consider the usage of delegatecalls. The semantics can often
be easily replicated with a simple call, which is easier to verify and audit.
===========================================================================
W2: Fallback handler can be set to address(this)
Impact: Warning Likelihood: N/A
Target: FallbackManager.sol Type: Data validation
Description
The fallback handler in the contract FallbackManager can be set to
address(this) by Safe. It could bypass the Safe’s authorized modifier in
exceptional cases.
The authorized modifier enforces a self-call. The fallback handler contains the
following code:
// The msg.sender address is shifted to the left by 12 bytes to remove the
padding
// Then the address without padding is stored right after the calldata
mstore(calldatasize(), shl(96, caller()))
// Add 20 bytes for the address appended add the end
let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)
If the msg.sender is a specially crafted address, the first 4 bytes of the
address may correspond to some function selector. It could be called if such
a function has the authorized modifier.
So even though the first call will fall into the fallback function, the second
one might not.
In the current implementation, this should not be possible because even if
the selector matched, the call would revert on abi.decoding of the arguments
(because the caller’s address does not constitute proper calldata for such a
function call).
Recommendation
Ensure the fallback handler cannot be set to address(this). This will not
reduce the functionality of the fallback handler and will ensure that the
handler cannot be set to address(this) by accident.
Fix 1.1
Client’s response:
• Add require(handler != this)
• Add test
• Add in-code documentation
Pull request #534 with a complete fix.
===========================================================================
W3: Removed owner's stored hash
Impact: Warning Likelihood: N/A
Target: Safe.sol Type: Redundant
memory
Description
The Safe provides to approve specific messages by owners.
function approveHash(bytes32 hashToApprove) external {
  require(owners[msg.sender] != address(0), "GS030");
  approvedHashes[msg.sender][hashToApprove] = 1;
  emit ApproveHash(hashToApprove, msg.sender);
}
However, when one of the owners is removed, the hash of the message
he/she approved before remains stored. This fact violates the condition that
only owners can make message approvals.
Recommendation
Even though the pre-approved message hashes are not exploitable, there is
no reason to store hashes of the removed owner. Therefore, the hash of the
removed owner should be removed from the storage.
Fix 1.1
Client’s response:
• Add documentation that hashes stay valid
Pull request #538 with added in-code documentation.
===========================================================================
W4: Singleton address at slot 0
Impact: Warning Likelihood: N/A
Target: SafeProxy.sol Type: Proxy pattern
Description
The SafeProxy contract uses the proxy pattern to delegate calls to the logic
contract. The address of the logic contract is stored at slot 0.
contract SafeProxy {
  // Singleton always needs to be first declared variable, to ensure that
it is at the same location in the contracts to which calls are delegated.
  // To reduce deployment costs this variable is internal and needs to be
retrieved via `getStorageAt`
  address internal singleton;
This is prone to error as it requires that the singleton variable is always the
first declared variable in the contract. If not, a slot collision can happen, and
the address can get overwritten.
Recommendation
If there are no compatibility issues (like upgrading between different safe
versions), the unstructured storage pattern should be performed, as it is
much less prone to errors. In the long term, the unstructured storage pattern
should be preferred for developing new contracts.
The OpenZeppelin contracts follow this pattern:
bytes32 private constant implementationPosition = bytes32(uint256(
  keccak256('eip1967.proxy.implementation')) - 1
));
More information can be found in the [OpenZeppelin
documentation](https://docs.openzeppelin.com/upgrades-plugins/1.x/
proxies#unstructured-storage-proxies).
===========================================================================
W5: Call to disableModule can be frontrun
Impact: Warning Likelihood: N/A
Target: Safe.sol, ModuleManager.sol Type: Frontrunning
Description
Modules can be added to the Safe and removed. Removing a module is done
by calling the disableModule function. However, the disabled transaction can
be front-run by a malicious module. Because the module can perform state
changes in the Safe it also can entirely mitigate the effect of the
disableModule call.
Recommendation
This issue cannot be mitigated as it is inherent to the Safe design. The issue
is included to demonstrate further the potential dangers of using modules.
Fix 1.1
Client’s response:
• "As mentioned in the report modules are “omnipotent” and
need to be considered carefully, therefore this should be
considered when developing a protocol around the Safe core
contracts that provides security."
• Improve Module documentation
Pull request #539 with added documentation.
===========================================================================
W6: Threshold can be set too high
Impact: Warning Likelihood: N/A
Target: OwnerManager.sol Type: Data validation
Description
The 5.1.1.2 contract allows adding new owners and changing the threshold.
The threshold can be set to arbitrarily high values if it is lower than the
number of owners.
However, there is an implicit limit for the threshold imposed by the block gas
limit. If the threshold is set too high, supplying enough signatures will not be
possible because of the gas limit.
We ran some back-of-the-envelope calculations and found that the threshold
would have to reach unreasonable values before the gas limit would become a
problem, and thus this should be fine for any multi-sig.
Recommendation
Consider performing some more thorough calculations and setting a limit for
the threshold.
Fix 1.1
Client’s response:
• "This is highly dependent on the chain and the limits on
the chain. Even on mainnet the limit is quite high
therefore we don’t see a need for an immediate action
(beyond sharing it as part of the audit)"
===========================================================================
I1: Code and comment inconsistency
Impact: Info Likelihood: N/A
Target: Safe.sol, ModuleManager.sol Type: Code quality
Description
While declaring new variables in Safe contract, at the line #150 a zero value is
assigned,
uint256 moduleCount = 0;
at the line #276 it is not.
uint8 v;
Even though the compiler assigns a zero value to the variables, it is a good
practice not to mix the two approaches.
In the contract ModuleManager the code comment at line #160 refers to the
variable currentModule, which does not exist in the code.
the `currentModule` will always be either a module address
Recommendation
Stick with one approach for an assignment and use it consistently across the
codebase.
Update the in-code comment to refer to the correct variable.
Fix 1.1
Client’s response:
• Variable declaration: "No action because in our tests leaving a
variable non-initialized resulted in less gas consumption"
• The comment in ModuleManager was adjusted
Pull request #530 with adjusted in-code documentation.
===========================================================================
I2: Require should be assert
Impact: Info Likelihood: N/A
Target: OwnerManager.sol,
ModuleManager.sol
Type: Code quality
Description
The require statement is used instead of better suited assert at several
places in the code. The require statement checks conditions that are not
supposed to happen during regular operation. However, the assert statement
checks conditions that should always be true.
The following require statements should be asserts :
• OwnerManager.sol
◦ setupOwners #31
require(threshold == 0, "GS200");
• ModuleManager.sol
◦ setupModules #32
require(modules[SENTINEL_MODULES] == address(0), "GS100");
These invariant conditions should always be true and are not supposed to
happen during regular operations.
It is essential to remember that solidity version < 0.8.0 (allowed version for
Safe contracts) failing asserts are returning invalid opcode, which consumes
all remaining gas. On the other hand, require is returning unused gas.
Recommendation
The asserts provide more information for reviewers and auditors because
they convey that the given condition should always be true. Using requires
may be confusing because it implies that the condition could sometimes
revert.
Fix 1.1
Client’s response:
• "The current version of the Safe uses Solidity 0.7.6 where
require does not use up all gas. To prevent unexpected
behavior this will not be changed in this version"